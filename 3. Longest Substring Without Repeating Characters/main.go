// 3. Самая длинная подстрока без повторяющихся символов
// Дана строка s, найдите длину самой длинной из них. Подстрока без повторения символов.

// Интуиция, лежащая в основе трех решений, заключается в итеративном поиске самой длинной подстроки без повторения
// символов путем поддержания подхода скользящего окна. Мы используем два указателя ( leftи right) для представления
// границ текущей подстроки. По мере итерации по строке мы обновляем указатели и настраиваем окно для размещения новых
// уникальных символов и устранения повторяющихся символов.

// Подход 1 - Набор
// Мы используем набор ( charSet) для отслеживания уникальных символов в текущей подстроке.
// Мы поддерживаем два указателя, leftи right, для представления границ текущей подстроки.
// Переменная maxLengthотслеживает длину самой длинной подстроки, встреченной на данный момент.
// Мы перебираем строку, используя rightуказатель.
// Если текущего символа нет в наборе ( charSet), это означает, что у нас есть новый уникальный символ.
// Вставляем персонажа в набор и обновляем maxLengthпри необходимости.
// Если символ уже присутствует в наборе, он указывает на повторяющийся символ в текущей подстроке.
// В этом случае мы перемещаем leftуказатель вперед, удаляя символы из набора до тех пор, пока повторяющийся символ не исчезнет.
// Вставляем текущий символ в набор и продолжаем итерацию.
// Наконец, мы возвращаем maxLengthдлину самой длинной подстроки без повторяющихся символов.

package main

import "fmt"

func contain(s []rune, r rune) bool {
	for _, e := range s {
		if e == r {
			return true
		}
	}
	return false
}

func lengthOfLongestSubstring(s string) int {

	maxLen := 0

	sub_set := []rune{}

	l := 0
	for r := 0; r < len(s); r++ {
		if contain(sub_set, rune(s[r])) {
			for contain(sub_set, rune(s[r])) {
				sub_set = sub_set[1:]
				l++
			}
		} else {
			maxLen = max(r-l+1, maxLen)
		}
		sub_set = append(sub_set, rune(s[r]))
	}

	return maxLen
}

func main() {
	arr := []string{
		"abcabcbb",
		"bbbbb",
		"pwwkew",
	}

	for _, s := range arr {
		fmt.Println(lengthOfLongestSubstring(s))
	}
}
